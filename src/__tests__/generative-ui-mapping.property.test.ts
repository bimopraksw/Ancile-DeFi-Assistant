/**
 * Property-Based Tests for Generative UI Component Mapping
 * 
 * Feature: defi-intent-interface, Property 6: Generative UI Component Mapping
 * Validates: Requirements 5.1, 5.2, 6.5
 * 
 * Tests that tool calls generated by the AI are immediately mapped to the appropriate
 * React components (SwapCard or BalanceCard) with correct parameter passing.
 */

import { describe, it, expect } from "vitest";
import * as fc from "fast-check";
import { isToolPart } from "@/components/chat/ToolInvocationRenderer";
import { SUPPORTED_CHAINS, TOKEN_WHITELIST } from "@/lib/schemas";

/**
 * Simulated tool part structure matching the AI SDK format.
 */
interface ToolPart {
  type: string;
  state: string;
  input?: Record<string, unknown>;
  output?: unknown;
  errorText?: string;
}

// Use ToolPart in type guard to avoid unused warning
// eslint-disable-next-line @typescript-eslint/no-unused-vars
const _isToolPartType = (part: unknown): part is ToolPart => {
  return typeof part === "object" && part !== null && "type" in part;
};

/**
 * Simulated message part for testing.
 */
interface MessagePart {
  type: string;
  text?: string;
  state?: string;
  input?: Record<string, unknown>;
}

/**
 * Helper to generate valid swap tool parts.
 */
const swapToolPartArb = fc.record({
  type: fc.constant("tool-swapTokens"),
  state: fc.constantFrom(
    "input-streaming",
    "input-available",
    "output-available",
    "output-error"
  ),
  input: fc.record({
    tokenIn: fc.constantFrom(...TOKEN_WHITELIST.ethereum),
    tokenOut: fc.constantFrom(...TOKEN_WHITELIST.ethereum),
    amount: fc.integer({ min: 1, max: 1000000 }),
    chain: fc.constantFrom(...SUPPORTED_CHAINS),
  }),
});

/**
 * Helper to generate valid balance tool parts.
 */
const balanceToolPartArb = fc.record({
  type: fc.constant("tool-checkBalance"),
  state: fc.constantFrom(
    "input-streaming",
    "input-available",
    "output-available",
    "output-error"
  ),
  input: fc.record({
    token: fc.constantFrom(...TOKEN_WHITELIST.ethereum),
    chain: fc.constantFrom(...SUPPORTED_CHAINS),
  }),
});

/**
 * Helper to generate text parts.
 */
const textPartArb = fc.record({
  type: fc.constant("text"),
  text: fc.string({ minLength: 1, maxLength: 200 }),
});

/**
 * Helper to generate any tool part.
 */
const anyToolPartArb = fc.oneof(swapToolPartArb, balanceToolPartArb);

/**
 * Helper to generate any message part.
 */
const anyMessagePartArb = fc.oneof(
  textPartArb,
  swapToolPartArb,
  balanceToolPartArb
) as fc.Arbitrary<MessagePart>;

describe("Property 6: Generative UI Component Mapping", () => {
  /**
   * Property: For any swap tool part, the type should correctly identify it as a tool.
   */
  it("should correctly identify swap tool parts", () => {
    fc.assert(
      fc.property(swapToolPartArb, (toolPart) => {
        expect(isToolPart(toolPart as MessagePart)).toBe(true);
        expect(toolPart.type).toBe("tool-swapTokens");
      }),
      { numRuns: 100 }
    );
  });

  /**
   * Property: For any balance tool part, the type should correctly identify it as a tool.
   */
  it("should correctly identify balance tool parts", () => {
    fc.assert(
      fc.property(balanceToolPartArb, (toolPart) => {
        expect(isToolPart(toolPart as MessagePart)).toBe(true);
        expect(toolPart.type).toBe("tool-checkBalance");
      }),
      { numRuns: 100 }
    );
  });

  /**
   * Property: For any text part, it should NOT be identified as a tool part.
   */
  it("should correctly identify text parts as non-tool parts", () => {
    fc.assert(
      fc.property(textPartArb, (textPart) => {
        expect(isToolPart(textPart as MessagePart)).toBe(false);
        expect(textPart.type).toBe("text");
      }),
      { numRuns: 100 }
    );
  });

  /**
   * Property: For any swap tool part with input-available state, all required
   * swap parameters should be present.
   */
  it("should ensure swap tool parts have all required parameters", () => {
    fc.assert(
      fc.property(
        swapToolPartArb.filter((p) => p.state === "input-available"),
        (toolPart) => {
          expect(toolPart.input).toBeDefined();
          expect(toolPart.input!.tokenIn).toBeDefined();
          expect(toolPart.input!.tokenOut).toBeDefined();
          expect(toolPart.input!.amount).toBeDefined();
          expect(toolPart.input!.chain).toBeDefined();
          expect(typeof toolPart.input!.tokenIn).toBe("string");
          expect(typeof toolPart.input!.tokenOut).toBe("string");
          expect(typeof toolPart.input!.amount).toBe("number");
          expect(typeof toolPart.input!.chain).toBe("string");
        }
      ),
      { numRuns: 100 }
    );
  });

  /**
   * Property: For any balance tool part with input-available state, all required
   * balance parameters should be present.
   */
  it("should ensure balance tool parts have all required parameters", () => {
    fc.assert(
      fc.property(
        balanceToolPartArb.filter((p) => p.state === "input-available"),
        (toolPart) => {
          expect(toolPart.input).toBeDefined();
          expect(toolPart.input!.token).toBeDefined();
          expect(toolPart.input!.chain).toBeDefined();
          expect(typeof toolPart.input!.token).toBe("string");
          expect(typeof toolPart.input!.chain).toBe("string");
        }
      ),
      { numRuns: 100 }
    );
  });

  /**
   * Property: For any tool part, the chain parameter should be a supported chain.
   */
  it("should ensure tool parts use supported chains", () => {
    fc.assert(
      fc.property(anyToolPartArb, (toolPart) => {
        if (toolPart.input?.chain) {
          expect(SUPPORTED_CHAINS).toContain(toolPart.input.chain);
        }
      }),
      { numRuns: 100 }
    );
  });

  /**
   * Property: For any swap tool part, tokens should be from the whitelist.
   */
  it("should ensure swap tool parts use whitelisted tokens", () => {
    fc.assert(
      fc.property(swapToolPartArb, (toolPart) => {
        if (toolPart.input) {
          const allTokens = Object.values(TOKEN_WHITELIST).flat();
          expect(allTokens).toContain(toolPart.input.tokenIn);
          expect(allTokens).toContain(toolPart.input.tokenOut);
        }
      }),
      { numRuns: 100 }
    );
  });

  /**
   * Property: For any balance tool part, token should be from the whitelist.
   */
  it("should ensure balance tool parts use whitelisted tokens", () => {
    fc.assert(
      fc.property(balanceToolPartArb, (toolPart) => {
        if (toolPart.input) {
          const allTokens = Object.values(TOKEN_WHITELIST).flat();
          expect(allTokens).toContain(toolPart.input.token);
        }
      }),
      { numRuns: 100 }
    );
  });

  /**
   * Property: For any tool part, the state should be one of the valid states.
   */
  it("should ensure tool parts have valid states", () => {
    const validStates = [
      "input-streaming",
      "input-available",
      "output-available",
      "output-error",
      "approval-requested",
      "approval-responded",
      "output-denied",
    ];

    fc.assert(
      fc.property(anyToolPartArb, (toolPart) => {
        expect(validStates).toContain(toolPart.state);
      }),
      { numRuns: 100 }
    );
  });

  /**
   * Property: For any swap tool part, amount should be positive.
   */
  it("should ensure swap amounts are positive", () => {
    fc.assert(
      fc.property(swapToolPartArb, (toolPart) => {
        if (toolPart.input?.amount !== undefined) {
          expect(toolPart.input.amount).toBeGreaterThan(0);
        }
      }),
      { numRuns: 100 }
    );
  });

  /**
   * Property: Tool type extraction should correctly identify the tool name.
   */
  it("should correctly extract tool name from type", () => {
    fc.assert(
      fc.property(anyToolPartArb, (toolPart) => {
        const toolName = toolPart.type.replace("tool-", "");
        expect(["swapTokens", "checkBalance"]).toContain(toolName);
      }),
      { numRuns: 100 }
    );
  });

  /**
   * Property: For any array of message parts, filtering for tool parts should
   * return only parts with type starting with "tool-".
   */
  it("should correctly filter tool parts from mixed message parts", () => {
    fc.assert(
      fc.property(
        fc.array(anyMessagePartArb, { minLength: 1, maxLength: 10 }),
        (parts) => {
          const toolParts = parts.filter((p) => isToolPart(p));
          const nonToolParts = parts.filter((p) => !isToolPart(p));

          toolParts.forEach((p) => {
            expect(p.type.startsWith("tool-")).toBe(true);
          });

          nonToolParts.forEach((p) => {
            expect(p.type.startsWith("tool-")).toBe(false);
          });
        }
      ),
      { numRuns: 100 }
    );
  });

  /**
   * Property: The count of tool parts plus non-tool parts should equal total parts.
   */
  it("should partition message parts correctly", () => {
    fc.assert(
      fc.property(
        fc.array(anyMessagePartArb, { minLength: 0, maxLength: 20 }),
        (parts) => {
          const toolParts = parts.filter((p) => isToolPart(p));
          const nonToolParts = parts.filter((p) => !isToolPart(p));
          expect(toolParts.length + nonToolParts.length).toBe(parts.length);
        }
      ),
      { numRuns: 100 }
    );
  });
});
