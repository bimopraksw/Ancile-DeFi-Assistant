/**
 * Property-Based Tests for Structured Tool Call Generation
 * 
 * Feature: defi-intent-interface, Property 2: Structured Tool Call Generation
 * Validates: Requirements 2.1, 2.2, 2.3
 * 
 * Tests that the DeFi_Agent generates properly structured tool calls that conform
 * to strict Zod schemas and include all required parameters for the requested operation.
 */

import { describe, it, expect } from "vitest";
import * as fc from "fast-check";
import { z } from "zod";
import {
  SUPPORTED_CHAINS,
  TOKEN_WHITELIST,
  SwapToolParamsSchema,
  BalanceToolParamsSchema,
} from "@/lib/schemas";

/**
 * Schema for swap tool call structure (as generated by AI)
 */
const SwapToolCallSchema = z.object({
  toolName: z.literal("swapTokens"),
  args: SwapToolParamsSchema,
});

/**
 * Schema for balance tool call structure (as generated by AI)
 */
const BalanceToolCallSchema = z.object({
  toolName: z.literal("checkBalance"),
  args: BalanceToolParamsSchema,
});

/**
 * Combined schema for any valid tool call
 */
const AnyToolCallSchema = z.discriminatedUnion("toolName", [
  z.object({
    toolName: z.literal("swapTokens"),
    args: z.object({
      tokenIn: z.string(),
      tokenOut: z.string(),
      amount: z.number().positive(),
      chain: z.enum(SUPPORTED_CHAINS),
    }),
  }),
  z.object({
    toolName: z.literal("checkBalance"),
    args: z.object({
      token: z.string(),
      chain: z.enum(SUPPORTED_CHAINS),
    }),
  }),
]);

describe("Property 2: Structured Tool Call Generation", () => {
  /**
   * Property: For any valid swap parameters, a properly structured tool call
   * should pass schema validation.
   */
  it("should generate valid swap tool calls for any valid parameters", () => {
    fc.assert(
      fc.property(
        fc.constantFrom(...SUPPORTED_CHAINS),
        fc.integer({ min: 1, max: 1000000 }),
        (chain, amount) => {
          const chainTokens = TOKEN_WHITELIST[chain];
          if (chainTokens.length < 2) return;
          
          const toolCall = {
            toolName: "swapTokens" as const,
            args: {
              tokenIn: chainTokens[0],
              tokenOut: chainTokens[1],
              amount,
              chain,
            },
          };
          
          const result = SwapToolCallSchema.safeParse(toolCall);
          expect(result.success).toBe(true);
        }
      ),
      { numRuns: 100 }
    );
  });

  /**
   * Property: For any valid balance parameters, a properly structured tool call
   * should pass schema validation.
   */
  it("should generate valid balance tool calls for any valid parameters", () => {
    fc.assert(
      fc.property(
        fc.constantFrom(...SUPPORTED_CHAINS),
        (chain) => {
          const chainTokens = TOKEN_WHITELIST[chain];
          
          const toolCall = {
            toolName: "checkBalance" as const,
            args: {
              token: chainTokens[0],
              chain,
            },
          };
          
          const result = BalanceToolCallSchema.safeParse(toolCall);
          expect(result.success).toBe(true);
        }
      ),
      { numRuns: 100 }
    );
  });


  /**
   * Property: Tool calls with invalid tool names should fail validation.
   */
  it("should reject tool calls with invalid tool names", () => {
    fc.assert(
      fc.property(
        fc.string().filter((s) => s !== "swapTokens" && s !== "checkBalance"),
        fc.constantFrom(...SUPPORTED_CHAINS),
        (invalidToolName, chain) => {
          const chainTokens = TOKEN_WHITELIST[chain];
          
          const toolCall = {
            toolName: invalidToolName,
            args: {
              token: chainTokens[0],
              chain,
            },
          };
          
          const result = AnyToolCallSchema.safeParse(toolCall);
          expect(result.success).toBe(false);
        }
      ),
      { numRuns: 100 }
    );
  });

  /**
   * Property: Swap tool calls must have all required parameters.
   */
  it("should require all parameters for swap tool calls", () => {
    fc.assert(
      fc.property(
        fc.constantFrom(...SUPPORTED_CHAINS),
        fc.integer({ min: 1, max: 1000000 }),
        fc.constantFrom("tokenIn", "tokenOut", "amount", "chain"),
        (chain, amount, missingField) => {
          const chainTokens = TOKEN_WHITELIST[chain];
          if (chainTokens.length < 2) return;
          
          const completeArgs: Record<string, unknown> = {
            tokenIn: chainTokens[0],
            tokenOut: chainTokens[1],
            amount,
            chain,
          };
          
          // Remove one required field
          delete completeArgs[missingField];
          
          const toolCall = {
            toolName: "swapTokens" as const,
            args: completeArgs,
          };
          
          const result = SwapToolCallSchema.safeParse(toolCall);
          expect(result.success).toBe(false);
        }
      ),
      { numRuns: 100 }
    );
  });

  /**
   * Property: Balance tool calls must have all required parameters.
   */
  it("should require all parameters for balance tool calls", () => {
    fc.assert(
      fc.property(
        fc.constantFrom(...SUPPORTED_CHAINS),
        fc.constantFrom("token", "chain"),
        (chain, missingField) => {
          const chainTokens = TOKEN_WHITELIST[chain];
          
          const completeArgs: Record<string, unknown> = {
            token: chainTokens[0],
            chain,
          };
          
          // Remove one required field
          delete completeArgs[missingField];
          
          const toolCall = {
            toolName: "checkBalance" as const,
            args: completeArgs,
          };
          
          const result = BalanceToolCallSchema.safeParse(toolCall);
          expect(result.success).toBe(false);
        }
      ),
      { numRuns: 100 }
    );
  });

  /**
   * Property: Tool calls should preserve all parameter values through validation.
   */
  it("should preserve parameter values through validation", () => {
    fc.assert(
      fc.property(
        fc.constantFrom(...SUPPORTED_CHAINS),
        fc.integer({ min: 1, max: 1000000 }),
        (chain, amount) => {
          const chainTokens = TOKEN_WHITELIST[chain];
          if (chainTokens.length < 2) return;
          
          const originalArgs = {
            tokenIn: chainTokens[0],
            tokenOut: chainTokens[1],
            amount,
            chain,
          };
          
          const toolCall = {
            toolName: "swapTokens" as const,
            args: originalArgs,
          };
          
          const result = SwapToolCallSchema.safeParse(toolCall);
          
          if (result.success) {
            expect(result.data.args.tokenIn).toBe(originalArgs.tokenIn);
            expect(result.data.args.tokenOut).toBe(originalArgs.tokenOut);
            expect(result.data.args.amount).toBe(originalArgs.amount);
            expect(result.data.args.chain).toBe(originalArgs.chain);
          }
        }
      ),
      { numRuns: 100 }
    );
  });

  /**
   * Property: The discriminated union should correctly identify tool types.
   */
  it("should correctly discriminate between tool call types", () => {
    fc.assert(
      fc.property(
        fc.constantFrom(...SUPPORTED_CHAINS),
        fc.integer({ min: 1, max: 1000000 }),
        fc.boolean(),
        (chain, amount, isSwap) => {
          const chainTokens = TOKEN_WHITELIST[chain];
          if (chainTokens.length < 2) return;
          
          const toolCall = isSwap
            ? {
                toolName: "swapTokens" as const,
                args: {
                  tokenIn: chainTokens[0],
                  tokenOut: chainTokens[1],
                  amount,
                  chain,
                },
              }
            : {
                toolName: "checkBalance" as const,
                args: {
                  token: chainTokens[0],
                  chain,
                },
              };
          
          const result = AnyToolCallSchema.safeParse(toolCall);
          expect(result.success).toBe(true);
          
          if (result.success) {
            expect(result.data.toolName).toBe(isSwap ? "swapTokens" : "checkBalance");
          }
        }
      ),
      { numRuns: 100 }
    );
  });

  /**
   * Property: Amount must be positive for swap operations.
   */
  it("should reject non-positive amounts in swap tool calls", () => {
    fc.assert(
      fc.property(
        fc.constantFrom(...SUPPORTED_CHAINS),
        fc.integer({ max: 0 }),
        (chain, invalidAmount) => {
          const chainTokens = TOKEN_WHITELIST[chain];
          if (chainTokens.length < 2) return;
          
          const toolCall = {
            toolName: "swapTokens" as const,
            args: {
              tokenIn: chainTokens[0],
              tokenOut: chainTokens[1],
              amount: invalidAmount,
              chain,
            },
          };
          
          const result = SwapToolCallSchema.safeParse(toolCall);
          expect(result.success).toBe(false);
        }
      ),
      { numRuns: 100 }
    );
  });
});
